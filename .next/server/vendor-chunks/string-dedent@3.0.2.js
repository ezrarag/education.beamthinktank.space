"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/string-dedent@3.0.2";
exports.ids = ["vendor-chunks/string-dedent@3.0.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/string-dedent@3.0.2/node_modules/string-dedent/dist/dedent.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/string-dedent@3.0.2/node_modules/string-dedent/dist/dedent.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ dedent)\n/* harmony export */ });\nconst cache = new WeakMap();\nconst newline = /(\\n|\\r\\n?|\\u2028|\\u2029)/g;\nconst leadingWhitespace = /^\\s*/;\nconst nonWhitespace = /\\S/;\nconst slice = Array.prototype.slice;\nconst zero = '0'.charCodeAt(0);\nconst nine = '9'.charCodeAt(0);\nconst lowerA = 'a'.charCodeAt(0);\nconst lowerF = 'f'.charCodeAt(0);\nconst upperA = 'A'.charCodeAt(0);\nconst upperF = 'F'.charCodeAt(0);\nfunction dedent(arg) {\n    if (typeof arg === 'string') {\n        return process([arg])[0];\n    }\n    if (typeof arg === 'function') {\n        return function () {\n            const args = slice.call(arguments);\n            args[0] = processTemplateStringsArray(args[0]);\n            return arg.apply(this, args);\n        };\n    }\n    const strings = processTemplateStringsArray(arg);\n    // TODO: This is just `String.cooked`: https://tc39.es/proposal-string-cooked/\n    let s = getCooked(strings, 0);\n    for (let i = 1; i < strings.length; i++) {\n        s += arguments[i] + getCooked(strings, i);\n    }\n    return s;\n}\nfunction getCooked(strings, index) {\n    const str = strings[index];\n    if (str === undefined)\n        throw new TypeError(`invalid cooked string at index ${index}`);\n    return str;\n}\nfunction processTemplateStringsArray(strings) {\n    const cached = cache.get(strings);\n    if (cached)\n        return cached;\n    const raw = process(strings.raw);\n    const cooked = raw.map(cook);\n    Object.defineProperty(cooked, 'raw', {\n        value: Object.freeze(raw),\n    });\n    Object.freeze(cooked);\n    cache.set(strings, cooked);\n    return cooked;\n}\nfunction process(strings) {\n    // splitQuasis is an array of arrays. The inner array is contains text content lines on the\n    // even indices, and the newline char that ends the text content line on the odd indices.\n    // In the first array, the inner array's 0 index is the opening line of the template literal.\n    // In all other arrays, the inner array's 0 index is the continuation of the line directly after a\n    // template expression.\n    //\n    // Eg, in the following case:\n    //\n    // ```\n    // String.dedent`\n    //   first\n    //   ${expression} second\n    //   third\n    // `\n    // ```\n    //\n    // We expect the following splitQuasis:\n    //\n    // ```\n    // [\n    //   [\"\", \"\\n\", \"  first\", \"\\n\", \"  \"],\n    //   [\" second\", \"\\n\", \"  third\", \"\\n\", \"\"],\n    // ]\n    // ```\n    const splitQuasis = strings.map((quasi) => quasi.split(newline));\n    let common;\n    for (let i = 0; i < splitQuasis.length; i++) {\n        const lines = splitQuasis[i];\n        // The first split is the static text starting at the opening line until the first template\n        // expression (or the end of the template if there are no expressions).\n        const firstSplit = i === 0;\n        // The last split is all the static text after the final template expression until the closing\n        // line. If there are no template expressions, then the first split is also the last split.\n        const lastSplit = i + 1 === splitQuasis.length;\n        // The opening line must be empty (it very likely is) and it must not contain a template\n        // expression. The opening line's trailing newline char is removed.\n        if (firstSplit) {\n            // Length > 1 ensures there is a newline, and there is not a template expression.\n            if (lines.length === 1 || lines[0].length > 0) {\n                throw new Error('invalid content on opening line');\n            }\n            // Clear the captured newline char.\n            lines[1] = '';\n        }\n        // The closing line may only contain whitespace and must not contain a template expression. The\n        // closing line and its preceding newline are removed.\n        if (lastSplit) {\n            // Length > 1 ensures there is a newline, and there is not a template expression.\n            if (lines.length === 1 || nonWhitespace.test(lines[lines.length - 1])) {\n                throw new Error('invalid content on closing line');\n            }\n            // Clear the captured newline char, and the whitespace on the closing line.\n            lines[lines.length - 2] = '';\n            lines[lines.length - 1] = '';\n        }\n        // In the first spit, the index 0 is the opening line (which must be empty by now), and in all\n        // other splits, its the content trailing the template expression (and so can't be part of\n        // leading whitespace).\n        // Every odd index is the captured newline char, so we'll skip and only process evens.\n        for (let j = 2; j < lines.length; j += 2) {\n            const text = lines[j];\n            // If we are on the last line of this split, and we are not processing the last split (which\n            // is after all template expressions), then this line contains a template expression.\n            const lineContainsTemplateExpression = j + 1 === lines.length && !lastSplit;\n            // leadingWhitespace is guaranteed to match something, but it could be 0 chars.\n            const leading = leadingWhitespace.exec(text)[0];\n            // Empty lines do not affect the common indentation, and whitespace only lines are emptied\n            // (and also don't affect the comon indentation).\n            if (!lineContainsTemplateExpression && leading.length === text.length) {\n                lines[j] = '';\n                continue;\n            }\n            common = commonStart(leading, common);\n        }\n    }\n    const min = common ? common.length : 0;\n    return splitQuasis.map((lines) => {\n        let quasi = lines[0];\n        for (let i = 1; i < lines.length; i += 2) {\n            const newline = lines[i];\n            const text = lines[i + 1];\n            quasi += newline + text.slice(min);\n        }\n        return quasi;\n    });\n}\nfunction commonStart(a, b) {\n    if (b === undefined || a === b)\n        return a;\n    let i = 0;\n    for (const len = Math.min(a.length, b.length); i < len; i++) {\n        if (a[i] !== b[i])\n            break;\n    }\n    return a.slice(0, i);\n}\nfunction cook(raw) {\n    let out = '';\n    let start = 0;\n    // We need to find every backslash escape sequence, and cook the escape into a real char.\n    let i = 0;\n    while ((i = raw.indexOf('\\\\', i)) > -1) {\n        out += raw.slice(start, i);\n        // If the backslash is the last char of the string, then it was an invalid sequence.\n        // This can't actually happen in a tagged template literal, but could happen if you manually\n        // invoked the tag with an array.\n        if (++i === raw.length)\n            return undefined;\n        const next = raw[i++];\n        switch (next) {\n            // Escaped control codes need to be individually processed.\n            case 'b':\n                out += '\\b';\n                break;\n            case 't':\n                out += '\\t';\n                break;\n            case 'n':\n                out += '\\n';\n                break;\n            case 'v':\n                out += '\\v';\n                break;\n            case 'f':\n                out += '\\f';\n                break;\n            case 'r':\n                out += '\\r';\n                break;\n            // Escaped line terminators just skip the char.\n            case '\\r':\n                // Treat `\\r\\n` as a single terminator.\n                if (i < raw.length && raw[i] === '\\n')\n                    ++i;\n            // fall through\n            case '\\n':\n            case '\\u2028':\n            case '\\u2029':\n                break;\n            // `\\0` is a null control char, but `\\0` followed by another digit is an illegal octal escape.\n            case '0':\n                if (isDigit(raw, i))\n                    return undefined;\n                out += '\\0';\n                break;\n            // Hex escapes must contain 2 hex chars.\n            case 'x': {\n                const n = parseHex(raw, i, i + 2);\n                if (n === -1)\n                    return undefined;\n                i += 2;\n                out += String.fromCharCode(n);\n                break;\n            }\n            // Unicode escapes contain either 4 chars, or an unlimited number between `{` and `}`.\n            // The hex value must not overflow 0x10ffff.\n            case 'u': {\n                let n;\n                if (i < raw.length && raw[i] === '{') {\n                    const end = raw.indexOf('}', ++i);\n                    if (end === -1)\n                        return undefined;\n                    n = parseHex(raw, i, end);\n                    i = end + 1;\n                }\n                else {\n                    n = parseHex(raw, i, i + 4);\n                    i += 4;\n                }\n                if (n === -1 || n > 0x10ffff)\n                    return undefined;\n                out += String.fromCodePoint(n);\n                break;\n            }\n            default:\n                if (isDigit(next, 0))\n                    return undefined;\n                out += next;\n        }\n        start = i;\n    }\n    return out + raw.slice(start);\n}\nfunction isDigit(str, index) {\n    const c = str.charCodeAt(index);\n    return c >= zero && c <= nine;\n}\nfunction parseHex(str, index, end) {\n    if (end >= str.length)\n        return -1;\n    let n = 0;\n    for (; index < end; index++) {\n        const c = hexToInt(str.charCodeAt(index));\n        if (c === -1)\n            return -1;\n        n = n * 16 + c;\n    }\n    return n;\n}\nfunction hexToInt(c) {\n    if (c >= zero && c <= nine)\n        return c - zero;\n    if (c >= lowerA && c <= lowerF)\n        return c - lowerA + 10;\n    if (c >= upperA && c <= upperF)\n        return c - upperA + 10;\n    return -1;\n}\n\n\n//# sourceMappingURL=dedent.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3RyaW5nLWRlZGVudEAzLjAuMi9ub2RlX21vZHVsZXMvc3RyaW5nLWRlZGVudC9kaXN0L2RlZGVudC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxNQUFNO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLFFBQVE7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iZWFtLWVkdWNhdGlvbi1zaXRlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0cmluZy1kZWRlbnRAMy4wLjIvbm9kZV9tb2R1bGVzL3N0cmluZy1kZWRlbnQvZGlzdC9kZWRlbnQubWpzP2Y4MjIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgbmV3bGluZSA9IC8oXFxufFxcclxcbj98XFx1MjAyOHxcXHUyMDI5KS9nO1xuY29uc3QgbGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccyovO1xuY29uc3Qgbm9uV2hpdGVzcGFjZSA9IC9cXFMvO1xuY29uc3Qgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5jb25zdCB6ZXJvID0gJzAnLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBuaW5lID0gJzknLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBsb3dlckEgPSAnYScuY2hhckNvZGVBdCgwKTtcbmNvbnN0IGxvd2VyRiA9ICdmJy5jaGFyQ29kZUF0KDApO1xuY29uc3QgdXBwZXJBID0gJ0EnLmNoYXJDb2RlQXQoMCk7XG5jb25zdCB1cHBlckYgPSAnRicuY2hhckNvZGVBdCgwKTtcbmZ1bmN0aW9uIGRlZGVudChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MoW2FyZ10pWzBdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGFyZ3NbMF0gPSBwcm9jZXNzVGVtcGxhdGVTdHJpbmdzQXJyYXkoYXJnc1swXSk7XG4gICAgICAgICAgICByZXR1cm4gYXJnLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdHJpbmdzID0gcHJvY2Vzc1RlbXBsYXRlU3RyaW5nc0FycmF5KGFyZyk7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBqdXN0IGBTdHJpbmcuY29va2VkYDogaHR0cHM6Ly90YzM5LmVzL3Byb3Bvc2FsLXN0cmluZy1jb29rZWQvXG4gICAgbGV0IHMgPSBnZXRDb29rZWQoc3RyaW5ncywgMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHMgKz0gYXJndW1lbnRzW2ldICsgZ2V0Q29va2VkKHN0cmluZ3MsIGkpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGdldENvb2tlZChzdHJpbmdzLCBpbmRleCkge1xuICAgIGNvbnN0IHN0ciA9IHN0cmluZ3NbaW5kZXhdO1xuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBjb29rZWQgc3RyaW5nIGF0IGluZGV4ICR7aW5kZXh9YCk7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NUZW1wbGF0ZVN0cmluZ3NBcnJheShzdHJpbmdzKSB7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KHN0cmluZ3MpO1xuICAgIGlmIChjYWNoZWQpXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgY29uc3QgcmF3ID0gcHJvY2VzcyhzdHJpbmdzLnJhdyk7XG4gICAgY29uc3QgY29va2VkID0gcmF3Lm1hcChjb29rKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCAncmF3Jywge1xuICAgICAgICB2YWx1ZTogT2JqZWN0LmZyZWV6ZShyYXcpLFxuICAgIH0pO1xuICAgIE9iamVjdC5mcmVlemUoY29va2VkKTtcbiAgICBjYWNoZS5zZXQoc3RyaW5ncywgY29va2VkKTtcbiAgICByZXR1cm4gY29va2VkO1xufVxuZnVuY3Rpb24gcHJvY2VzcyhzdHJpbmdzKSB7XG4gICAgLy8gc3BsaXRRdWFzaXMgaXMgYW4gYXJyYXkgb2YgYXJyYXlzLiBUaGUgaW5uZXIgYXJyYXkgaXMgY29udGFpbnMgdGV4dCBjb250ZW50IGxpbmVzIG9uIHRoZVxuICAgIC8vIGV2ZW4gaW5kaWNlcywgYW5kIHRoZSBuZXdsaW5lIGNoYXIgdGhhdCBlbmRzIHRoZSB0ZXh0IGNvbnRlbnQgbGluZSBvbiB0aGUgb2RkIGluZGljZXMuXG4gICAgLy8gSW4gdGhlIGZpcnN0IGFycmF5LCB0aGUgaW5uZXIgYXJyYXkncyAwIGluZGV4IGlzIHRoZSBvcGVuaW5nIGxpbmUgb2YgdGhlIHRlbXBsYXRlIGxpdGVyYWwuXG4gICAgLy8gSW4gYWxsIG90aGVyIGFycmF5cywgdGhlIGlubmVyIGFycmF5J3MgMCBpbmRleCBpcyB0aGUgY29udGludWF0aW9uIG9mIHRoZSBsaW5lIGRpcmVjdGx5IGFmdGVyIGFcbiAgICAvLyB0ZW1wbGF0ZSBleHByZXNzaW9uLlxuICAgIC8vXG4gICAgLy8gRWcsIGluIHRoZSBmb2xsb3dpbmcgY2FzZTpcbiAgICAvL1xuICAgIC8vIGBgYFxuICAgIC8vIFN0cmluZy5kZWRlbnRgXG4gICAgLy8gICBmaXJzdFxuICAgIC8vICAgJHtleHByZXNzaW9ufSBzZWNvbmRcbiAgICAvLyAgIHRoaXJkXG4gICAgLy8gYFxuICAgIC8vIGBgYFxuICAgIC8vXG4gICAgLy8gV2UgZXhwZWN0IHRoZSBmb2xsb3dpbmcgc3BsaXRRdWFzaXM6XG4gICAgLy9cbiAgICAvLyBgYGBcbiAgICAvLyBbXG4gICAgLy8gICBbXCJcIiwgXCJcXG5cIiwgXCIgIGZpcnN0XCIsIFwiXFxuXCIsIFwiICBcIl0sXG4gICAgLy8gICBbXCIgc2Vjb25kXCIsIFwiXFxuXCIsIFwiICB0aGlyZFwiLCBcIlxcblwiLCBcIlwiXSxcbiAgICAvLyBdXG4gICAgLy8gYGBgXG4gICAgY29uc3Qgc3BsaXRRdWFzaXMgPSBzdHJpbmdzLm1hcCgocXVhc2kpID0+IHF1YXNpLnNwbGl0KG5ld2xpbmUpKTtcbiAgICBsZXQgY29tbW9uO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BsaXRRdWFzaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzcGxpdFF1YXNpc1tpXTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHNwbGl0IGlzIHRoZSBzdGF0aWMgdGV4dCBzdGFydGluZyBhdCB0aGUgb3BlbmluZyBsaW5lIHVudGlsIHRoZSBmaXJzdCB0ZW1wbGF0ZVxuICAgICAgICAvLyBleHByZXNzaW9uIChvciB0aGUgZW5kIG9mIHRoZSB0ZW1wbGF0ZSBpZiB0aGVyZSBhcmUgbm8gZXhwcmVzc2lvbnMpLlxuICAgICAgICBjb25zdCBmaXJzdFNwbGl0ID0gaSA9PT0gMDtcbiAgICAgICAgLy8gVGhlIGxhc3Qgc3BsaXQgaXMgYWxsIHRoZSBzdGF0aWMgdGV4dCBhZnRlciB0aGUgZmluYWwgdGVtcGxhdGUgZXhwcmVzc2lvbiB1bnRpbCB0aGUgY2xvc2luZ1xuICAgICAgICAvLyBsaW5lLiBJZiB0aGVyZSBhcmUgbm8gdGVtcGxhdGUgZXhwcmVzc2lvbnMsIHRoZW4gdGhlIGZpcnN0IHNwbGl0IGlzIGFsc28gdGhlIGxhc3Qgc3BsaXQuXG4gICAgICAgIGNvbnN0IGxhc3RTcGxpdCA9IGkgKyAxID09PSBzcGxpdFF1YXNpcy5sZW5ndGg7XG4gICAgICAgIC8vIFRoZSBvcGVuaW5nIGxpbmUgbXVzdCBiZSBlbXB0eSAoaXQgdmVyeSBsaWtlbHkgaXMpIGFuZCBpdCBtdXN0IG5vdCBjb250YWluIGEgdGVtcGxhdGVcbiAgICAgICAgLy8gZXhwcmVzc2lvbi4gVGhlIG9wZW5pbmcgbGluZSdzIHRyYWlsaW5nIG5ld2xpbmUgY2hhciBpcyByZW1vdmVkLlxuICAgICAgICBpZiAoZmlyc3RTcGxpdCkge1xuICAgICAgICAgICAgLy8gTGVuZ3RoID4gMSBlbnN1cmVzIHRoZXJlIGlzIGEgbmV3bGluZSwgYW5kIHRoZXJlIGlzIG5vdCBhIHRlbXBsYXRlIGV4cHJlc3Npb24uXG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID09PSAxIHx8IGxpbmVzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY29udGVudCBvbiBvcGVuaW5nIGxpbmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjYXB0dXJlZCBuZXdsaW5lIGNoYXIuXG4gICAgICAgICAgICBsaW5lc1sxXSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjbG9zaW5nIGxpbmUgbWF5IG9ubHkgY29udGFpbiB3aGl0ZXNwYWNlIGFuZCBtdXN0IG5vdCBjb250YWluIGEgdGVtcGxhdGUgZXhwcmVzc2lvbi4gVGhlXG4gICAgICAgIC8vIGNsb3NpbmcgbGluZSBhbmQgaXRzIHByZWNlZGluZyBuZXdsaW5lIGFyZSByZW1vdmVkLlxuICAgICAgICBpZiAobGFzdFNwbGl0KSB7XG4gICAgICAgICAgICAvLyBMZW5ndGggPiAxIGVuc3VyZXMgdGhlcmUgaXMgYSBuZXdsaW5lLCBhbmQgdGhlcmUgaXMgbm90IGEgdGVtcGxhdGUgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEgfHwgbm9uV2hpdGVzcGFjZS50ZXN0KGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjb250ZW50IG9uIGNsb3NpbmcgbGluZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNhcHR1cmVkIG5ld2xpbmUgY2hhciwgYW5kIHRoZSB3aGl0ZXNwYWNlIG9uIHRoZSBjbG9zaW5nIGxpbmUuXG4gICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAyXSA9ICcnO1xuICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiB0aGUgZmlyc3Qgc3BpdCwgdGhlIGluZGV4IDAgaXMgdGhlIG9wZW5pbmcgbGluZSAod2hpY2ggbXVzdCBiZSBlbXB0eSBieSBub3cpLCBhbmQgaW4gYWxsXG4gICAgICAgIC8vIG90aGVyIHNwbGl0cywgaXRzIHRoZSBjb250ZW50IHRyYWlsaW5nIHRoZSB0ZW1wbGF0ZSBleHByZXNzaW9uIChhbmQgc28gY2FuJ3QgYmUgcGFydCBvZlxuICAgICAgICAvLyBsZWFkaW5nIHdoaXRlc3BhY2UpLlxuICAgICAgICAvLyBFdmVyeSBvZGQgaW5kZXggaXMgdGhlIGNhcHR1cmVkIG5ld2xpbmUgY2hhciwgc28gd2UnbGwgc2tpcCBhbmQgb25seSBwcm9jZXNzIGV2ZW5zLlxuICAgICAgICBmb3IgKGxldCBqID0gMjsgaiA8IGxpbmVzLmxlbmd0aDsgaiArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbGluZXNbal07XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgb24gdGhlIGxhc3QgbGluZSBvZiB0aGlzIHNwbGl0LCBhbmQgd2UgYXJlIG5vdCBwcm9jZXNzaW5nIHRoZSBsYXN0IHNwbGl0ICh3aGljaFxuICAgICAgICAgICAgLy8gaXMgYWZ0ZXIgYWxsIHRlbXBsYXRlIGV4cHJlc3Npb25zKSwgdGhlbiB0aGlzIGxpbmUgY29udGFpbnMgYSB0ZW1wbGF0ZSBleHByZXNzaW9uLlxuICAgICAgICAgICAgY29uc3QgbGluZUNvbnRhaW5zVGVtcGxhdGVFeHByZXNzaW9uID0gaiArIDEgPT09IGxpbmVzLmxlbmd0aCAmJiAhbGFzdFNwbGl0O1xuICAgICAgICAgICAgLy8gbGVhZGluZ1doaXRlc3BhY2UgaXMgZ3VhcmFudGVlZCB0byBtYXRjaCBzb21ldGhpbmcsIGJ1dCBpdCBjb3VsZCBiZSAwIGNoYXJzLlxuICAgICAgICAgICAgY29uc3QgbGVhZGluZyA9IGxlYWRpbmdXaGl0ZXNwYWNlLmV4ZWModGV4dClbMF07XG4gICAgICAgICAgICAvLyBFbXB0eSBsaW5lcyBkbyBub3QgYWZmZWN0IHRoZSBjb21tb24gaW5kZW50YXRpb24sIGFuZCB3aGl0ZXNwYWNlIG9ubHkgbGluZXMgYXJlIGVtcHRpZWRcbiAgICAgICAgICAgIC8vIChhbmQgYWxzbyBkb24ndCBhZmZlY3QgdGhlIGNvbW9uIGluZGVudGF0aW9uKS5cbiAgICAgICAgICAgIGlmICghbGluZUNvbnRhaW5zVGVtcGxhdGVFeHByZXNzaW9uICYmIGxlYWRpbmcubGVuZ3RoID09PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxpbmVzW2pdID0gJyc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21tb24gPSBjb21tb25TdGFydChsZWFkaW5nLCBjb21tb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1pbiA9IGNvbW1vbiA/IGNvbW1vbi5sZW5ndGggOiAwO1xuICAgIHJldHVybiBzcGxpdFF1YXNpcy5tYXAoKGxpbmVzKSA9PiB7XG4gICAgICAgIGxldCBxdWFzaSA9IGxpbmVzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbGluZXNbaSArIDFdO1xuICAgICAgICAgICAgcXVhc2kgKz0gbmV3bGluZSArIHRleHQuc2xpY2UobWluKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVhc2k7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjb21tb25TdGFydChhLCBiKSB7XG4gICAgaWYgKGIgPT09IHVuZGVmaW5lZCB8fCBhID09PSBiKVxuICAgICAgICByZXR1cm4gYTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGEuc2xpY2UoMCwgaSk7XG59XG5mdW5jdGlvbiBjb29rKHJhdykge1xuICAgIGxldCBvdXQgPSAnJztcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIC8vIFdlIG5lZWQgdG8gZmluZCBldmVyeSBiYWNrc2xhc2ggZXNjYXBlIHNlcXVlbmNlLCBhbmQgY29vayB0aGUgZXNjYXBlIGludG8gYSByZWFsIGNoYXIuXG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlICgoaSA9IHJhdy5pbmRleE9mKCdcXFxcJywgaSkpID4gLTEpIHtcbiAgICAgICAgb3V0ICs9IHJhdy5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIC8vIElmIHRoZSBiYWNrc2xhc2ggaXMgdGhlIGxhc3QgY2hhciBvZiB0aGUgc3RyaW5nLCB0aGVuIGl0IHdhcyBhbiBpbnZhbGlkIHNlcXVlbmNlLlxuICAgICAgICAvLyBUaGlzIGNhbid0IGFjdHVhbGx5IGhhcHBlbiBpbiBhIHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsLCBidXQgY291bGQgaGFwcGVuIGlmIHlvdSBtYW51YWxseVxuICAgICAgICAvLyBpbnZva2VkIHRoZSB0YWcgd2l0aCBhbiBhcnJheS5cbiAgICAgICAgaWYgKCsraSA9PT0gcmF3Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG5leHQgPSByYXdbaSsrXTtcbiAgICAgICAgc3dpdGNoIChuZXh0KSB7XG4gICAgICAgICAgICAvLyBFc2NhcGVkIGNvbnRyb2wgY29kZXMgbmVlZCB0byBiZSBpbmRpdmlkdWFsbHkgcHJvY2Vzc2VkLlxuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXGInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXHYnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXHInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gRXNjYXBlZCBsaW5lIHRlcm1pbmF0b3JzIGp1c3Qgc2tpcCB0aGUgY2hhci5cbiAgICAgICAgICAgIGNhc2UgJ1xccic6XG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgYFxcclxcbmAgYXMgYSBzaW5nbGUgdGVybWluYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IHJhdy5sZW5ndGggJiYgcmF3W2ldID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgY2FzZSAnXFx1MjAyOCc6XG4gICAgICAgICAgICBjYXNlICdcXHUyMDI5JzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGBcXDBgIGlzIGEgbnVsbCBjb250cm9sIGNoYXIsIGJ1dCBgXFwwYCBmb2xsb3dlZCBieSBhbm90aGVyIGRpZ2l0IGlzIGFuIGlsbGVnYWwgb2N0YWwgZXNjYXBlLlxuICAgICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICAgICAgaWYgKGlzRGlnaXQocmF3LCBpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcMCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBIZXggZXNjYXBlcyBtdXN0IGNvbnRhaW4gMiBoZXggY2hhcnMuXG4gICAgICAgICAgICBjYXNlICd4Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBwYXJzZUhleChyYXcsIGksIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5pY29kZSBlc2NhcGVzIGNvbnRhaW4gZWl0aGVyIDQgY2hhcnMsIG9yIGFuIHVubGltaXRlZCBudW1iZXIgYmV0d2VlbiBge2AgYW5kIGB9YC5cbiAgICAgICAgICAgIC8vIFRoZSBoZXggdmFsdWUgbXVzdCBub3Qgb3ZlcmZsb3cgMHgxMGZmZmYuXG4gICAgICAgICAgICBjYXNlICd1Jzoge1xuICAgICAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgcmF3Lmxlbmd0aCAmJiByYXdbaV0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSByYXcuaW5kZXhPZignfScsICsraSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgbiA9IHBhcnNlSGV4KHJhdywgaSwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGVuZCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuID0gcGFyc2VIZXgocmF3LCBpLCBpICsgNCk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IC0xIHx8IG4gPiAweDEwZmZmZilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQobik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChpc0RpZ2l0KG5leHQsIDApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG91dCArPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIG91dCArIHJhdy5zbGljZShzdGFydCk7XG59XG5mdW5jdGlvbiBpc0RpZ2l0KHN0ciwgaW5kZXgpIHtcbiAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID49IHplcm8gJiYgYyA8PSBuaW5lO1xufVxuZnVuY3Rpb24gcGFyc2VIZXgoc3RyLCBpbmRleCwgZW5kKSB7XG4gICAgaWYgKGVuZCA+PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAoOyBpbmRleCA8IGVuZDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBjID0gaGV4VG9JbnQoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKTtcbiAgICAgICAgaWYgKGMgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBuID0gbiAqIDE2ICsgYztcbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBoZXhUb0ludChjKSB7XG4gICAgaWYgKGMgPj0gemVybyAmJiBjIDw9IG5pbmUpXG4gICAgICAgIHJldHVybiBjIC0gemVybztcbiAgICBpZiAoYyA+PSBsb3dlckEgJiYgYyA8PSBsb3dlckYpXG4gICAgICAgIHJldHVybiBjIC0gbG93ZXJBICsgMTA7XG4gICAgaWYgKGMgPj0gdXBwZXJBICYmIGMgPD0gdXBwZXJGKVxuICAgICAgICByZXR1cm4gYyAtIHVwcGVyQSArIDEwO1xuICAgIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IHsgZGVkZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZGVudC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/string-dedent@3.0.2/node_modules/string-dedent/dist/dedent.mjs\n");

/***/ })

};
;